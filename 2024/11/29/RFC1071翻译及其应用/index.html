<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"dingdingqiuqiu.github.io.git","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="本文是对RFC1071标准的翻译，同时根据标准，用C语言实现了协议内容。">
<meta property="og:type" content="article">
<meta property="og:title" content="RFC1071翻译及其应用">
<meta property="og:url" content="https://dingdingqiuqiu.github.io.git/2024/11/29/RFC1071%E7%BF%BB%E8%AF%91%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/index.html">
<meta property="og:site_name" content="DDqiuqiu">
<meta property="og:description" content="本文是对RFC1071标准的翻译，同时根据标准，用C语言实现了协议内容。">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2024-11-29T13:15:01.000Z">
<meta property="article:modified_time" content="2024-11-30T18:23:30.422Z">
<meta property="article:author" content="P4yl04d">
<meta property="article:tag" content="计算机网络">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://dingdingqiuqiu.github.io.git/2024/11/29/RFC1071%E7%BF%BB%E8%AF%91%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>RFC1071翻译及其应用 | DDqiuqiu</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">DDqiuqiu</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://dingdingqiuqiu.github.io.git/2024/11/29/RFC1071%E7%BF%BB%E8%AF%91%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="P4yl04d">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DDqiuqiu">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          RFC1071翻译及其应用
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-11-29 21:15:01" itemprop="dateCreated datePublished" datetime="2024-11-29T21:15:01+08:00">2024-11-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-12-01 02:23:30" itemprop="dateModified" datetime="2024-12-01T02:23:30+08:00">2024-12-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>本文是对RFC1071标准的翻译，同时根据标准，用C语言实现了协议内容。</p>
<span id="more"></span>
<h3 id="原文翻译"><a href="#原文翻译" class="headerlink" title="原文翻译"></a>原文翻译</h3><p><a target="_blank" rel="noopener" href="https://dl.acm.org/doi/pdf/10.17487/RFC1071">https://dl.acm.org/doi/pdf/10.17487/RFC1071</a></p>
<h4 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h4><p>该标准总结了高效计算网际校验和的技术和算法。它不是一个标准，而是一组有用的实现技术。该标准的分发没有限制。</p>
<h4 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h4><p>该标准讨论了高效计算网际校验和的方法，这种校验和被用于标准的互联网协议，如 IP、UDP 和 TCP。</p>
<p>高效的校验和实现对良好的性能至关重要。随着实现技术的不断进步，协议处理的其他部分已得到优化，而校验和的计算往往成为 TCP 性能的瓶颈。例如，处理 TCP 数据字节时，每微秒的节省可能会在总体计算中带来显著的 CPU 时间节省。</p>
<p>总体来说，网际校验和算法非常简单：</p>
<p>(1) 相邻的8位(1字节)将被配对，形成16位数据，接着对这些16位数据求反码(1’s complement)。</p>
<p>(2) 为了生成校验和，首先清空校验和字段本身，然后计算涉及的16位数据的反码和，最后将计算得到的字段放入校验和字段中。</p>
<p>(3) 为了检查校验和，计算同一组的16位数据的反码和，包括校验和字段。如果结果是全1位（在反码中即表示-0），则校验通过。</p>
<p>假设需要计算的校验和是针对以下字节序列：<br><strong>A, B, C, D, …, Y, Z</strong>。使用[a, b]表示16位整数<strong>a*256 + b</strong>，其中<strong>a</strong>和<strong>b</strong>是字节。那么这些字节的16位1的补码和可以表示为以下两种形式之一：</p>
<script type="math/tex; mode=display">
[A, B] + [C, D] + ... + [Y, Z] \tag{1}</script><script type="math/tex; mode=display">
[A, B] + [C, D] + ... + [Z, 0] \tag{2}</script><p>其中，<code>+</code>表示1的补码加法。这两种情况分别对应字节数为偶数和奇数的情况。</p>
<p>在二进制补码机器上，1的补码和必须通过“进位回绕”（end-around carry）来计算，也就是说，任何从最重要位（最高位）溢出的部分，都需要加到最低位。具体的例子将在后面给出。</p>
<p>第2节讨论了这个校验和的特性，这些特性可以用于加速其计算。第3节包含了一些最重要的实现技术的数字示例。最后，第4节展示了适用于各种常见CPU类型的特定算法示例。我们感谢Van Jacobson和Charley Kline对这一部分算法的贡献。</p>
<p>网际校验和的特性最初由Bill Plummer在《IEN-45: 校验和功能设计》中讨论。由于《IEN-45》未被广泛传播，我们将其作为附录扩展包含在本RFC中。</p>
<h3 id="2-计算校验和"><a href="#2-计算校验和" class="headerlink" title="2. 计算校验和"></a>2. 计算校验和</h3><p>这个简单的校验和具有许多出色的数学特性，能够加速其计算，接下来我们将讨论这些特性。</p>
<h4 id="A-交换律与结合律"><a href="#A-交换律与结合律" class="headerlink" title="(A) 交换律与结合律"></a>(A) 交换律与结合律</h4><p>只要遵循字节的奇偶分配规则，求和的顺序可以任意改变，且可以随意将其拆分成若干组。例如，和式 <strong>[1]</strong> 可以拆分为：</p>
<script type="math/tex; mode=display">
([A,B] + [C,D] + ... + [J,0]) + ([0,K] + ... + [Y,Z])  \tag{3}</script><p>这样，和式仍然保持不变。这意味着，我们可以灵活地调整字节的求和顺序，拆分成多个部分来加速计算。</p>
<h4 id="B-字节顺序独立性"><a href="#B-字节顺序独立性" class="headerlink" title="(B) 字节顺序独立性"></a>(B) 字节顺序独立性</h4><p>16位整数的和可以不依赖于字节顺序来计算。因此，如果我们计算交换字节顺序的和：</p>
<script type="math/tex; mode=display">
[B,A] + [D,C] + ... + [Z,Y]                              \tag{4}</script><p>其结果与 <strong>[1]</strong> 相同，唯一的区别是字节的顺序被交换了！为什么是这样呢？因为无论如何交换字节，进位的过程是一样的：从第15位到第0位，以及从第7位到第8位。换句话说，一致地交换字节只是将和式中的位旋转，而不会影响它们的内部顺序。</p>
<p>因此，无论底层硬件的字节顺序（”大端”或”小端”）如何，求和的方式完全一样。例如，假设我们在一个”小端”机器上计算，数据按网络字节顺序（”大端”）存储。读取每个16位字时，字节会交换，结果是和式 <strong>[4]</strong>；但是，将结果存回内存时，和式的字节顺序会重新交换回网络字节顺序。</p>
<p>字节交换也可以显式地用于处理边界对齐问题。例如，<strong>[3]</strong> 中的第二组可以不考虑字节的奇偶顺序，直接按以下方式计算：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[K,L] + ... + [Z,0]</span><br></pre></td></tr></table></figure>
<p>如果在将这个和式加到第一组之前对它进行字节交换，就可以避免字节的对齐问题。具体的例子将在下面给出。</p>
<h4 id="C-并行求和"><a href="#C-并行求和" class="headerlink" title="(C) 并行求和"></a>(C) 并行求和</h4><p>在那些字长是16位倍数的机器上，可以开发出更高效的实现。由于加法满足结合律，我们不必按照消息中整数出现的顺序进行求和。相反，我们可以通过利用更大的字长并行地进行求和。</p>
<p>为了并行计算校验和，只需使用机器的原生字长进行1的补码加法。例如，在32位机器上，我们可以一次加4个字节：<code>[A,B,C,D] + ...</code>。当和式计算完成后，我们可以通过将长和式的16位段相加，将其“折叠”回16位。每次16位加法可能会产生新的进位，这些进位需要被加上。</p>
<p>此外，字节顺序依然不重要；我们可以用以下不同的方式对32位字进行求和：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="16.7ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 7381.4 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"></path></g><g data-mml-node="mi" transform="translate(278,0)"><path data-c="1D437" d="M287 628Q287 635 230 637Q207 637 200 638T193 647Q193 655 197 667T204 682Q206 683 403 683Q570 682 590 682T630 676Q702 659 752 597T803 431Q803 275 696 151T444 3L430 1L236 0H125H72Q48 0 41 2T33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM703 469Q703 507 692 537T666 584T629 613T590 629T555 636Q553 636 541 636T512 636T479 637H436Q392 637 386 627Q384 623 313 339T242 52Q242 48 253 48T330 47Q335 47 349 47T373 46Q499 46 581 128Q617 164 640 212T683 339T703 469Z"></path></g><g data-mml-node="mo" transform="translate(1106,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mi" transform="translate(1550.7,0)"><path data-c="1D436" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z"></path></g><g data-mml-node="mo" transform="translate(2310.7,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mi" transform="translate(2755.3,0)"><path data-c="1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"></path></g><g data-mml-node="mo" transform="translate(3514.3,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mi" transform="translate(3959,0)"><path data-c="1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"></path></g><g data-mml-node="mo" transform="translate(4709,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"></path></g><g data-mml-node="mo" transform="translate(5209.2,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mo" transform="translate(6209.4,0)"><path data-c="2026" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60ZM525 60Q525 84 542 102T585 120Q609 120 627 104T646 61Q646 36 629 18T586 0T543 17T525 60ZM972 60Q972 84 989 102T1032 120Q1056 120 1074 104T1093 61Q1093 36 1076 18T1033 0T990 17T972 60Z"></path></g></g></g></svg></mjx-container>或者 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="16.7ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 7381.4 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"></path></g><g data-mml-node="mi" transform="translate(278,0)"><path data-c="1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"></path></g><g data-mml-node="mo" transform="translate(1037,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mi" transform="translate(1481.7,0)"><path data-c="1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"></path></g><g data-mml-node="mo" transform="translate(2231.7,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mi" transform="translate(2676.3,0)"><path data-c="1D437" d="M287 628Q287 635 230 637Q207 637 200 638T193 647Q193 655 197 667T204 682Q206 683 403 683Q570 682 590 682T630 676Q702 659 752 597T803 431Q803 275 696 151T444 3L430 1L236 0H125H72Q48 0 41 2T33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM703 469Q703 507 692 537T666 584T629 613T590 629T555 636Q553 636 541 636T512 636T479 637H436Q392 637 386 627Q384 623 313 339T242 52Q242 48 253 48T330 47Q335 47 349 47T373 46Q499 46 581 128Q617 164 640 212T683 339T703 469Z"></path></g><g data-mml-node="mo" transform="translate(3504.3,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mi" transform="translate(3949,0)"><path data-c="1D436" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z"></path></g><g data-mml-node="mo" transform="translate(4709,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"></path></g><g data-mml-node="mo" transform="translate(5209.2,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mo" transform="translate(6209.4,0)"><path data-c="2026" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60ZM525 60Q525 84 542 102T585 120Q609 120 627 104T646 61Q646 36 629 18T586 0T543 17T525 60ZM972 60Q972 84 989 102T1032 120Q1056 120 1074 104T1093 61Q1093 36 1076 18T1033 0T990 17T972 60Z"></path></g></g></g></svg></mjx-container></p>
<p>然后，根据需要对最终的16位和式进行字节交换。任何能够收集字节进行求和的排列方式都是允许的。请参阅下面的示例。允许任何排列，将所有偶数数据字节收集到一个总和字节中，将奇数数据字节收集到另一个总和字节中。还有进一步的编码技术可用于加速校验和计算。</p>
<h3 id="3-进一步优化校验和计算"><a href="#3-进一步优化校验和计算" class="headerlink" title="3.进一步优化校验和计算"></a>3.进一步优化校验和计算</h3><p>在校验和的计算过程中，还可以通过一些进一步的编码技术来加速计算过程。</p>
<h4 id="1-延迟进位（Deferred-Carries）"><a href="#1-延迟进位（Deferred-Carries）" class="headerlink" title="(1) 延迟进位（Deferred Carries）"></a>(1) 延迟进位（Deferred Carries）</h4><p>根据不同机器的架构，延迟处理进位直到主要求和循环结束可能会更加高效。<br>一种方法是将16位字求和并存储在一个32位累加器中，这样溢出就会积累到高16位。此方法通常避免了需要进位感知指令，但它需要进行比直接加32位段更多的加法。是否采用这种方法取决于硬件架构的具体细节，因为有些情况下加32位段可能会更快。</p>
<h4 id="2-展开循环（Unwinding-Loops）"><a href="#2-展开循环（Unwinding-Loops）" class="headerlink" title="(2) 展开循环（Unwinding Loops）"></a>(2) 展开循环（Unwinding Loops）</h4><p>为了减少循环的开销，通常可以将内层求和循环展开，在一次循环遍历中复制一系列加法指令。这种技术通常会带来显著的性能提升，尽管它可能会使程序的逻辑变得更加复杂。</p>
<h4 id="3-与数据复制结合（Combine-with-Data-Copying）"><a href="#3-与数据复制结合（Combine-with-Data-Copying）" class="headerlink" title="(3) 与数据复制结合（Combine with Data Copying）"></a>(3) 与数据复制结合（Combine with Data Copying）</h4><p>像校验和计算一样，从一个内存位置复制数据到另一个位置也涉及逐字节的开销。在两者的情况下，瓶颈基本上是内存总线，即数据提取的速度。在一些机器上（特别是相对较慢和简单的微型计算机），通过将内存到内存的复制与校验和计算结合，可以显著减少开销，避免多次访问内存。例如，数据只需访问一次，就能同时进行复制和校验和计算。</p>
<h4 id="4-增量更新（Incremental-Update）"><a href="#4-增量更新（Incremental-Update）" class="headerlink" title="(4) 增量更新（Incremental Update）"></a>(4) 增量更新（Incremental Update）</h4><p>最后，在某些情况下，当更新头部字段时，可以避免重新计算整个校验和。最著名的例子是网关更改IP头中的TTL字段，但也有其他类似的情况（例如，当更新源路由时）。在这些情况下，可以通过增量更新校验和，而无需重新扫描整个消息或数据报。</p>
<p>为了更新校验和，只需将已更改的16位整数的差值加上。为什么这种方法有效呢？因为每个16位整数都有加法逆元，并且加法是结合律的。由此可得，给定原始值m、新值m’和旧校验和C，新的校验和C’可以通过以下公式计算：</p>
<script type="math/tex; mode=display">
C' = C + (-m) + m' = C + (m' - m) \tag{5}</script><p>这种方法避免了重新计算整个校验和的过程，只需要处理那些已经改变的字段，从而提高了效率。</p>
<h3 id="4-数值计算示例"><a href="#4-数值计算示例" class="headerlink" title="4. 数值计算示例"></a>4. 数值计算示例</h3><p>以下是如何在一个采用补码表示的计算机上显式地计算1的补码校验和的示例。<br> 示例展示了以字节、16位字（常规和交换顺序）、以及32位字（3种顺序）逐步计算的结果。所有的数值均以十六进制表示。</p>
<h4 id="字节逐步计算、正常顺序和交换顺序"><a href="#字节逐步计算、正常顺序和交换顺序" class="headerlink" title="字节逐步计算、正常顺序和交换顺序"></a>字节逐步计算、正常顺序和交换顺序</h4><div class="table-container">
<table>
<thead>
<tr>
<th>步骤</th>
<th>字节逐步计算</th>
<th>正常顺序 (“Normal Order”)</th>
<th>交换顺序 (“Swapped Order”)</th>
</tr>
</thead>
<tbody>
<tr>
<td>字节 0/1</td>
<td>00 01</td>
<td>0001</td>
<td>0100</td>
</tr>
<tr>
<td>字节 2/3</td>
<td>f2   03</td>
<td>f203</td>
<td>03f2</td>
</tr>
<tr>
<td>字节 4/5</td>
<td>f4   f5</td>
<td>f4f5</td>
<td>f5f4</td>
</tr>
<tr>
<td>字节 6/7</td>
<td>f6   f7</td>
<td>f6f7</td>
<td>f7f6</td>
</tr>
<tr>
<td>初次求和 (Sum1)</td>
<td>2dc   1f0</td>
<td>2ddf0</td>
<td>1f2dc</td>
</tr>
<tr>
<td>进位值 (Carrys)</td>
<td>1     2</td>
<td>2</td>
<td>1</td>
</tr>
<tr>
<td>第二次求和 (Sum2)</td>
<td>dd   f2</td>
<td>ddf2</td>
<td>f2dd</td>
</tr>
<tr>
<td>最终交换</td>
<td>dd   f2</td>
<td>ddf2</td>
<td>ddf2</td>
</tr>
</tbody>
</table>
</div>
<hr>
<h4 id="32位字逐步计算（3种不同的顺序）"><a href="#32位字逐步计算（3种不同的顺序）" class="headerlink" title="32位字逐步计算（3种不同的顺序）"></a>32位字逐步计算（3种不同的顺序）</h4><div class="table-container">
<table>
<thead>
<tr>
<th>步骤</th>
<th>正常顺序 (Normal Order)</th>
<th>交换顺序1 (Swapped Order 1)</th>
<th>交换顺序2 (Swapped Order 2)</th>
</tr>
</thead>
<tbody>
<tr>
<td>字节 0/1/2/3</td>
<td>0001f203</td>
<td>010003f2</td>
<td>03f20100</td>
</tr>
<tr>
<td>字节 4/5/6/7</td>
<td>f4f5f6f7</td>
<td>f5f4f7f6</td>
<td>f7f6f5f4</td>
</tr>
<tr>
<td>初次求和 (Sum1)</td>
<td>0f4f7e8fa</td>
<td>0f6f4fbe8</td>
<td>0fbe8f6f4</td>
</tr>
<tr>
<td>进位值 (Carrys)</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>高半部分 (Top half)</td>
<td>f4f7</td>
<td>f6f4</td>
<td>fbe8</td>
</tr>
<tr>
<td>低半部分 (Bottom half)</td>
<td>e8fa</td>
<td>fbe8</td>
<td>f6f4</td>
</tr>
<tr>
<td>第二次求和 (Sum2)</td>
<td>1ddf1</td>
<td>1f2dc</td>
<td>1f2dc</td>
</tr>
<tr>
<td>进位值 (Carrys)</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>第三次求和 (Sum3)</td>
<td>ddf2</td>
<td>f2dd</td>
<td>f2dd</td>
</tr>
<tr>
<td>最终交换</td>
<td>ddf2</td>
<td>ddf2</td>
<td>ddf2</td>
</tr>
</tbody>
</table>
</div>
<hr>
<h4 id="分组计算示例"><a href="#分组计算示例" class="headerlink" title="分组计算示例"></a>分组计算示例</h4><p>以下是将数据分为两组的情况，其中第二组从奇数边界开始：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>步骤</th>
<th>字节逐步计算</th>
<th>正常顺序</th>
</tr>
</thead>
<tbody>
<tr>
<td>字节 0/1</td>
<td>00   01</td>
<td>0001</td>
</tr>
<tr>
<td>字节 2/(填充为0)</td>
<td>f2   (00)</td>
<td>f200</td>
</tr>
<tr>
<td>第一次求和 (Sum1)</td>
<td>f2   01</td>
<td>f201</td>
</tr>
<tr>
<td>字节 4/5</td>
<td>03   f4</td>
<td>03f4</td>
</tr>
<tr>
<td>字节 6/7</td>
<td>f5   f6</td>
<td>f5f6</td>
</tr>
<tr>
<td>字节 8/(填充为0)</td>
<td>f7   (00)</td>
<td>f700</td>
</tr>
<tr>
<td>第二次求和 (Sum2)</td>
<td>—-</td>
<td>1f0ea</td>
</tr>
<tr>
<td>第二次求和 (Sum2)</td>
<td>—-</td>
<td>f0ea</td>
</tr>
<tr>
<td>进位值 (Carry)</td>
<td>—-</td>
<td>1</td>
</tr>
<tr>
<td>第三次求和 (Sum3)</td>
<td>—-</td>
<td>f0eb</td>
</tr>
<tr>
<td>第一次求和 (Sum1)</td>
<td>—-</td>
<td>f201</td>
</tr>
<tr>
<td>第三次求和字节交换</td>
<td>—-</td>
<td>ebf0</td>
</tr>
<tr>
<td>最后求和 (Sum4)</td>
<td>—-</td>
<td>1ddf1</td>
</tr>
<tr>
<td>最后求和 (Sum4)</td>
<td>—-</td>
<td>ddf1</td>
</tr>
<tr>
<td>进位值 (Carry)</td>
<td>—-</td>
<td>1</td>
</tr>
<tr>
<td>最终校验和 (Sum5)</td>
<td>—-</td>
<td>ddf2</td>
</tr>
</tbody>
</table>
</div>
<p>通过这些数值示例，可以清楚地看到校验和计算在不同分组和顺序上的一致性。尽管计算路径和顺序不同，最终结果都归一为校验和 <code>ddf2</code>，验证了算法的正确性和可移植性。</p>
<h3 id="4-实现示例"><a href="#4-实现示例" class="headerlink" title="4. 实现示例"></a>4. 实现示例</h3><p>在本节中，我们展示了在各种CPU上被证明高效的互联网校验和实现算法示例。每个示例均仅展示算法核心部分，不包含环境代码（如子程序链接）或特殊情况代码。</p>
<h4 id="4-1-使用-“C”-实现的互联网校验和算法"><a href="#4-1-使用-“C”-实现的互联网校验和算法" class="headerlink" title="4.1 使用 “C” 实现的互联网校验和算法"></a>4.1 使用 “C” 实现的互联网校验和算法</h4><p>以下的 C 代码实现展示了一种算法，其内循环在 32 位累加器中每次累加 16 位数据：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">short</span> <span class="title function_">checksum</span><span class="params">(<span class="type">void</span> *addr, <span class="type">int</span> count)</span> {</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 计算从地址 "addr" 开始的 "count" 字节数据的互联网校验和。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">register</span> <span class="type">long</span> sum = <span class="number">0</span>;  <span class="comment">// 使用 32 位寄存器作为累加器</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主循环：每次处理 16 位数据</span></span><br><span class="line">    <span class="keyword">while</span> (count &gt; <span class="number">1</span>) {</span><br><span class="line">        sum += *(<span class="type">unsigned</span> <span class="type">short</span> *) addr++;  <span class="comment">// 累加当前 16 位数据</span></span><br><span class="line">        count -= <span class="number">2</span>;  <span class="comment">// 剩余数据长度减少 2 字节</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理剩余的 1 个字节（如果存在）</span></span><br><span class="line">    <span class="keyword">if</span> (count &gt; <span class="number">0</span>) {</span><br><span class="line">        sum += *(<span class="type">unsigned</span> <span class="type">char</span> *) addr;  <span class="comment">// 将剩余的 8 位字节累加到 sum</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 32 位累加器的高 16 位与低 16 位相加，直到没有进位</span></span><br><span class="line">    <span class="keyword">while</span> (sum &gt;&gt; <span class="number">16</span>) {</span><br><span class="line">        sum = (sum &amp; <span class="number">0xFFFF</span>) + (sum &gt;&gt; <span class="number">16</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对最终的累加结果取反，得到校验和</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">short</span>) ~sum;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="翻译及解释"><a href="#翻译及解释" class="headerlink" title="翻译及解释"></a>翻译及解释</h3><ol>
<li><strong>初始化累加器</strong>： 使用 <code>long</code> 类型（32 位）的 <code>sum</code> 变量作为累加器，用于存储累加的 16 位数据和可能的溢出。</li>
<li><strong>主循环</strong>：<ul>
<li>每次从地址 <code>addr</code> 中读取一个 16 位数据（两个字节），并累加到 <code>sum</code>。</li>
<li>地址指针 <code>addr</code> 每次移动两个字节。</li>
<li>同时，剩余字节数 <code>count</code> 减少 2。</li>
</ul>
</li>
<li><strong>处理剩余字节</strong>：<ul>
<li>如果字节数是奇数，会剩余一个字节未处理。</li>
<li>使用类型转换为 <code>unsigned char</code>，读取并累加到 <code>sum</code>。</li>
</ul>
</li>
<li><strong>折叠进位</strong>：<ul>
<li>当 <code>sum</code> 超过 16 位时，将高 16 位与低 16 位相加。</li>
<li>重复此过程直到没有进位。</li>
</ul>
</li>
<li><strong>取反操作</strong>：<ul>
<li>最终对累加结果取反（按位取反），生成最终的校验和。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="示例说明"><a href="#示例说明" class="headerlink" title="示例说明"></a>示例说明</h3><p>这个算法适用于在 2’s 补码表示法的机器上实现 1’s 补码的加法运算，简洁而高效，同时考虑了数据对齐和进位的处理。</p>
<h4 id="4-2-Motorola-68020"><a href="#4-2-Motorola-68020" class="headerlink" title="4.2 Motorola 68020"></a>4.2 Motorola 68020</h4><p>以下算法用汇编语言为 Motorola 68020 芯片实现。该算法每次对 32 位数据进行累加，并将循环展开成 16 次重复。为了清晰起见，我们省略了当长度不是 4 的倍数时处理最后一个字的逻辑。结果存储在寄存器 <code>d0</code> 中。</p>
<p>在 20MHz 时钟频率下，这段代码对随机数据的处理速度测得为 <strong>134 微秒/千字节</strong>。该算法由 Van Jacobson 开发。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">movl    d1,d2                  | 将计数值复制到寄存器 d2</span><br><span class="line">lsrl    #6,d1                  | 计数值除以 64，得到循环次数</span><br><span class="line">andl    #0x3c,d2               | 找到不完整部分的大小（不足一个块）</span><br><span class="line">negl    d2                     | 对 d2 求补，处理偏移</span><br><span class="line">andb    #0xf,cc                | 清除 X 标志位（扩展进位标志）</span><br><span class="line">jmp     pc@(2$-.-2:b,d2)       | 根据偏移跳转到循环入口</span><br><span class="line">1$:                             | 开始内部循环...</span><br><span class="line">movl    a0@+,d2                | 从地址 a0 读取 32 位数据到 d2</span><br><span class="line">addxl   d2,d0                  | 将 d2 加到 d0，并加上扩展进位</span><br><span class="line">movl    a0@+,d2                | 从地址 a0 读取下一个 32 位数据到 d2</span><br><span class="line">addxl   d2,d0                  | 将 d2 加到 d0，并加上扩展进位</span><br><span class="line">                                | ...重复上述两步，共 14 次</span><br><span class="line">2$:</span><br><span class="line">3$:</span><br><span class="line">dbra    d1,1$                  | 如果 d1 非零，跳回到 1$（dbra 不影响 X）</span><br><span class="line">movl    d0,d1                  | 将 d0 的值复制到 d1，用于后续处理</span><br><span class="line">swap    d1                     | 交换 d1 的高 16 位和低 16 位（swap 不影响 X）</span><br><span class="line">addxw   d1,d0                  | 将 d1 加到 d0，并加上扩展进位</span><br><span class="line">jcc     3$                     | 如果无进位，跳回到 3$</span><br><span class="line">addw    #1,d0                  | 如果有进位，修正结果</span><br><span class="line">andl    #0xffff,d0             | 只保留 d0 的低 16 位，得到最终结果</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="翻译及解释-1"><a href="#翻译及解释-1" class="headerlink" title="翻译及解释"></a>翻译及解释</h3><ol>
<li><strong>初始化阶段</strong>：<ul>
<li><code>movl d1,d2</code>：将计数值复制到寄存器 <code>d2</code>。</li>
<li><code>lsrl #6,d1</code>：计算主循环的次数（每次循环处理 64 字节）。</li>
<li><code>andl #0x3c,d2</code>：获取不足一个块（64 字节）的数据部分。</li>
<li><code>negl d2</code>：求补，用于偏移计算。</li>
<li><code>andb #0xf,cc</code>：清除 X 标志位，确保后续加法的正确性。</li>
</ul>
</li>
<li><strong>主循环</strong>：<ul>
<li>每次循环从内存中读取两个 32 位字，并将它们逐一累加到寄存器 <code>d0</code> 中。</li>
<li>使用 <code>addxl</code> 指令执行加法，同时处理进位。</li>
</ul>
</li>
<li><strong>循环收尾</strong>：<ul>
<li>使用 <code>dbra</code> 指令递减计数器 <code>d1</code>，判断是否继续循环。</li>
</ul>
</li>
<li><strong>折叠进位</strong>：<ul>
<li><code>movl d0,d1</code>：将累加结果复制到 <code>d1</code>。</li>
<li><code>swap d1</code>：交换 <code>d1</code> 的高 16 位和低 16 位，方便高低位累加。</li>
<li><code>addxw d1,d0</code>：将 <code>d1</code> 的高低位累加到 <code>d0</code> 中，同时处理进位。</li>
<li>使用 <code>jcc</code> 指令判断是否需要进一步修正。</li>
</ul>
</li>
<li><strong>结果修正</strong>：<ul>
<li>如果有未处理的进位，用 <code>addw #1,d0</code> 修正。</li>
<li>使用 <code>andl #0xffff,d0</code> 确保结果为 16 位校验和。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="性能特点"><a href="#性能特点" class="headerlink" title="性能特点"></a>性能特点</h3><ul>
<li><strong>循环展开</strong>：通过每次处理 32 位数据和展开循环减少指令次数，从而提高效率。</li>
<li><strong>进位优化</strong>：利用 Motorola 68020 的硬件特性，通过 <code>addxl</code> 和 <code>addxw</code> 指令高效处理扩展进位。</li>
<li><strong>汇编优化</strong>：算法充分利用寄存器和指令特性，最小化内存访问次数。</li>
</ul>
<p>该实现在性能和硬件利用率上做出了良好权衡，适用于高效计算大数据块的校验和。</p>
<h3 id="4-3-Cray"><a href="#4-3-Cray" class="headerlink" title="4.3 Cray"></a>4.3 Cray</h3><p>以下是为 Cray CPU 编写的汇编语言示例，由 Charley Kline 提供。该算法将校验和计算实现为向量操作，每次处理最多 512 字节，基本的求和单位为 32 位。为了简洁，示例省略了关于短块的许多细节。</p>
<p><strong>注册 A1</strong> 存储待计算校验和的 512 字节内存块的地址。首先，将数据的两个副本加载到两个向量寄存器中。一个寄存器将数据右移 32 位，另一个寄存器与 32 位掩码进行向量按位与操作。然后，将这两个向量加在一起。由于所有这些操作是链式执行的，因此每个时钟周期就能得到一个结果。接着，通过一个循环将结果向量中的每个元素加到一个标量寄存器中。最后，进行环绕进位（end-around carry）并将结果折叠为 16 位。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">EBM</span><br><span class="line">A0      A1                  ; A0 = A1, 设置内存地址</span><br><span class="line">VL      64                  ; 使用完整的向量（64 个元素）</span><br><span class="line">S1      &lt;32                 ; 从右侧形成 32 位掩码</span><br><span class="line">A2      32                  ; 32 位数据处理</span><br><span class="line">V1      ,A0,1               ; 加载数据包到 V1 向量寄存器</span><br><span class="line">V2      S1&amp;V1               ; 对 V1 向量寄存器的右侧 32 位应用掩码，结果存入 V2</span><br><span class="line">V3      V1&gt;A2               ; 对 V1 向量寄存器左侧 32 位进行右移 32 位，结果存入 V3</span><br><span class="line">V1      V2+V3               ; 将 V2 和 V3 相加，得到结果存入 V1</span><br><span class="line">A2      63                  ; 准备将结果向量折叠成标量值</span><br><span class="line">S1      0                   ; 初始化 S1 寄存器</span><br><span class="line">S4      &lt;16                 ; 从右侧形成 16 位掩码</span><br><span class="line">A4      16                  ; 设置 A4 为 16，进行 16 位的校验和处理</span><br><span class="line"></span><br><span class="line">CK$LOOP</span><br><span class="line">S2      V1,A2               ; 将 V1 向量寄存器的值加到 A2 中</span><br><span class="line">A2      A2-1                ; A2 减去 1，处理下一个元素</span><br><span class="line">A0      A2                  ; 将 A2 的值传递给 A0</span><br><span class="line">S1      S1+S2               ; 将 S2 加到 S1</span><br><span class="line">JAN     CK$LOOP             ; 如果没有完成，跳转到 CK$LOOP</span><br><span class="line"></span><br><span class="line">S2      S1&amp;S4               ; 对 S1 与 S4 进行按位与操作，形成右侧 16 位</span><br><span class="line">S1      S1&gt;A4               ; 将 S1 右移 16 位，形成左侧 16 位</span><br><span class="line">S1      S1+S2               ; 将左侧和右侧相加，结果存回 S1</span><br><span class="line">S2      S1&amp;S4               ; 再次对 S1 与 S4 进行按位与操作，形成右侧 16 位</span><br><span class="line">S1      S1&gt;A4               ; 将 S1 右移 16 位，形成左侧 16 位</span><br><span class="line">S1      S1+S2               ; 将左侧和右侧相加，结果存回 S1</span><br><span class="line">S1      #S1                 ; 对 S1 进行按位取反，得到最终校验和</span><br><span class="line">CMR                        ; 此时，S1 包含计算出的校验和</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="翻译及解释-2"><a href="#翻译及解释-2" class="headerlink" title="翻译及解释"></a>翻译及解释</h3><ol>
<li><strong>初始化阶段</strong>：<ul>
<li><strong>A0</strong> 和 <strong>A1</strong>：<code>A1</code> 存储内存块地址，<code>A0</code> 用来复制这个地址。</li>
<li><strong>VL 64</strong>：指定使用完整的 64 元素向量。</li>
<li><strong>S1 &lt;32</strong>：从右侧 32 位形成掩码，存入 <code>S1</code> 寄存器。</li>
<li><strong>A2 32</strong>：指定处理的数据单位为 32 位。</li>
<li><strong>V1</strong>：加载内存块的数据到向量寄存器 <code>V1</code>。</li>
<li><strong>V2 和 V3</strong>：通过向量按位与和右移操作，将数据分为两部分，并存入 <code>V2</code> 和 <code>V3</code>。</li>
<li><strong>V1 + V2</strong>：将这两部分相加，结果存入 <code>V1</code>。</li>
</ul>
</li>
<li><strong>计算过程</strong>：<ul>
<li><strong>S1</strong> 初始化为零。</li>
<li><strong>S4 &lt;16</strong>：从右侧形成 16 位掩码，用于后续的处理。</li>
<li><strong>A4 16</strong>：准备 16 位校验和的折叠操作。</li>
</ul>
</li>
<li><strong>折叠过程</strong>：<ul>
<li>通过 <code>CK$LOOP</code> 循环，每次将向量寄存器中的值加到标量寄存器 <code>S1</code> 中。</li>
<li>每次迭代更新 <code>A2</code>，并将累加结果加到 <code>S1</code>。</li>
<li>最终通过环绕进位和移位操作，将结果折叠为 16 位。</li>
</ul>
</li>
<li><strong>结果取反</strong>：<ul>
<li>最后一步对计算结果 <code>S1</code> 进行按位取反，得到最终的校验和。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="性能特点-1"><a href="#性能特点-1" class="headerlink" title="性能特点"></a>性能特点</h3><ul>
<li><strong>向量化操作</strong>：该算法利用 Cray 的向量处理能力，每次处理多个数据元素，大大提高了计算效率。</li>
<li><strong>流水线操作</strong>：通过链式操作，每个时钟周期就能完成一次计算。</li>
<li><strong>高效的折叠操作</strong>：通过有效的循环和移位操作，确保校验和的计算可以高效完成。</li>
<li><strong>环绕进位</strong>：采用环绕进位方法确保结果的正确性，符合 16 位校验和要求。</li>
</ul>
<p>这种实现方式非常适合于 Cray 这样的向量处理器，能够充分发挥硬件特性，进行大数据块的高效处理。</p>
<h3 id="4-4-IBM-370"><a href="#4-4-IBM-370" class="headerlink" title="4.4 IBM 370"></a>4.4 IBM 370</h3><p>以下是为 IBM 370 CPU 编写的汇编语言示例。该算法每次处理 4 字节数据。为了简洁起见，示例省略了在数据长度不是 4 的倍数时如何添加最后一个完整字（fullword）的逻辑，以及在必要时如何反转字节。计算结果存储在寄存器 <code>RCARRY</code> 中。</p>
<p>该算法在 IBM 3090 CPU 上的性能为每千字节 27 微秒，处理全 1 位数据时。如果处理时确保数据对齐，时间可以减少到每千字节 24.3 微秒（这需要在开始和结束时处理特定的情况，并且在需要时进行字节交换以补偿从奇数字节开始的情况）。</p>
<p><strong>说明：</strong></p>
<ul>
<li>寄存器 <code>RADDR</code> 和 <code>RCOUNT</code> 分别包含待计算校验和的数据块的地址和长度。</li>
<li><code>(RCARRY, RSUM)</code> 必须是偶数/奇数寄存器对。</li>
<li><code>(RCOUNT, RMOD)</code> 必须是偶数/奇数寄存器对。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">CHECKSUM  SR    RSUM,RSUM        ; 清空工作寄存器 RSUM</span><br><span class="line">          SR    RCARRY,RCARRY    ; 清空工作寄存器 RCARRY</span><br><span class="line">          LA    RONE,1           ; 设置常数 1</span><br><span class="line"></span><br><span class="line">          SRDA  RCOUNT,6         ; 将数据块长度 RCOUNT 除以 64</span><br><span class="line">          AR    RCOUNT,RONE      ; +1，使得循环次数为 RCOUNT + 1</span><br><span class="line">          SRL   RMOD,26          ; 将数据块的大小除以 64，结果保存在 RMOD</span><br><span class="line">          AR    RADDR,R3         ; 调整地址指针 RADDR，补偿开始前的偏移</span><br><span class="line">          S     RADDR,=F(64)     ; 跳过 64 字节对齐的偏移</span><br><span class="line">          SRL   RMOD,1           ; 将 RMOD 除以 4 再乘以 2，得到半字索引</span><br><span class="line">          LH    RMOD,DOPEVEC9(RMOD) ; 使用魔法向量 DOPEVEC9 获取偏移</span><br><span class="line">          B     LOOP(RMOD)       ; 跳入循环...</span><br><span class="line"></span><br><span class="line">* 内部循环：</span><br><span class="line"></span><br><span class="line">LOOP      AL    RSUM,0(,RADDR)   ; 加法逻辑：加上当前 4 字节</span><br><span class="line">          BC    12,*+6            ; 如果没有进位，跳过</span><br><span class="line">          AR    RCARRY,RONE       ; 如果有进位，向 RCARRY 添加 1（环绕进位）</span><br><span class="line">          AL    RSUM,4(,RADDR)   ; 加下一个 4 字节</span><br><span class="line">          BC    12,*+6            ; 如果没有进位，跳过</span><br><span class="line">          AR    RCARRY,RONE       ; 如果有进位，向 RCARRY 添加 1（环绕进位）</span><br><span class="line"></span><br><span class="line">* 接下来是其他 14 次重复操作（简化表述）</span><br><span class="line"></span><br><span class="line">          A     RADDR,=F'64'     ; 增加地址指针 RADDR</span><br><span class="line">          BCT   RCOUNT,LOOP      ; 当 RCOUNT 大于 0 时，跳回循环</span><br><span class="line"></span><br><span class="line">* 将进位加到结果并折叠为 16 位：</span><br><span class="line"></span><br><span class="line">          ALR   RCARRY,RSUM      ; 将 RSUM 和 RCARRY 相加</span><br><span class="line">          BC    12,*+6           ; 如果没有进位，跳过</span><br><span class="line">          AR    RCARRY,RONE      ; 如果有进位，向 RCARRY 添加 1（环绕进位）</span><br><span class="line">          SRDL  RCARRY,16        ; 将 32 位和折叠成 16 位</span><br><span class="line">          SRL   RSUM,16          ; 将结果右移 16 位</span><br><span class="line">          ALR   RCARRY,RSUM      ; 再次加上进位，得到最终结果</span><br><span class="line">          C     RCARRY,=X'0000FFFF' ; 检查最后是否有进位</span><br><span class="line">          BNH   DONE             ; 如果没有进位，跳转到 DONE</span><br><span class="line">          S     RCARRY,=X'0000FFFF' ; 如果有进位，重新调整 RCARRY</span><br><span class="line"></span><br><span class="line">DONE      X     RCARRY,=X'0000FFFF' ; 对 RCARRY 进行按位取反，得到 1 的补码</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="翻译及解释-3"><a href="#翻译及解释-3" class="headerlink" title="翻译及解释"></a>翻译及解释</h3><ol>
<li><strong>初始化阶段</strong>：<ul>
<li><code>SR    RSUM,RSUM</code> 和 <code>SR    RCARRY,RCARRY</code>：将寄存器 <code>RSUM</code> 和 <code>RCARRY</code> 清零。</li>
<li><code>LA    RONE,1</code>：将常数 1 加载到寄存器 <code>RONE</code>，用于后续的加法和循环。</li>
<li><code>SRDA  RCOUNT,6</code>：将数据块长度 <code>RCOUNT</code> 除以 64，结果存储在 <code>RCOUNT</code> 中。</li>
<li><code>AR    RCOUNT,RONE</code>：将 <code>RCOUNT</code> 加 1，表示循环次数为 <code>RCOUNT + 1</code>。</li>
<li><code>S     RADDR,=F(64)</code>：将 <code>RADDR</code> 偏移 64 字节，为进入循环做准备。</li>
<li><code>SRL   RMOD,1</code>：将 <code>RMOD</code> 除以 4，并乘以 2，得到半字索引，用于后续操作。</li>
</ul>
</li>
<li><strong>内循环</strong>：<ul>
<li><code>AL    RSUM,0(,RADDR)</code>：从内存中读取 4 字节数据并加到 <code>RSUM</code> 中。</li>
<li><code>BC    12,*+6</code>：检查是否有进位，如果没有进位则跳过。</li>
<li><code>AR    RCARRY,RONE</code>：如果有进位，则将进位加到 <code>RCARRY</code> 中。</li>
<li>重复这两个步骤，处理接下来的 4 字节数据，直到处理完所有数据。</li>
</ul>
</li>
<li><strong>地址更新与循环控制</strong>：<ul>
<li><code>A     RADDR,=F'64'</code>：更新地址指针 <code>RADDR</code>，指向下一个 64 字节的块。</li>
<li><code>BCT   RCOUNT,LOOP</code>：如果 <code>RCOUNT</code> 不为 0，则跳回循环，继续处理数据块。</li>
</ul>
</li>
<li><strong>折叠与进位处理</strong>：<ul>
<li>将 <code>RSUM</code> 和 <code>RCARRY</code> 相加，并检查是否有进位。如果有进位，则进行环绕进位操作。</li>
<li><code>SRDL  RCARRY,16</code>：将 32 位的 <code>RCARRY</code> 和 <code>RSUM</code> 折叠成 16 位。</li>
<li>最后，进行 1 的补码操作，得到校验和的最终结果。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="性能说明"><a href="#性能说明" class="headerlink" title="性能说明"></a>性能说明</h3><ul>
<li><strong>时间</strong>：该算法在 IBM 3090 CPU 上测得的性能是每千字节 27 微秒。如果通过确保数据对齐，时间可以减少到 24.3 微秒，这要求在开始和结束时处理特殊情况，如字节交换（特别是当数据块的起始位置是奇数字节时）。</li>
<li><strong>数据对齐</strong>：通过保证数据在字边界对齐，可以显著提高性能。</li>
</ul>
<p>这种实现充分利用了 IBM 370 的处理能力，特别是在处理大块数据时，通过高效的内存访问和环绕进位操作确保了校验和计算的正确性和效率。</p>
<h3 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h3><p>校验和（Checksum）是数据包中用来检测在传输过程中可能发生的错误的一种机制。对于如 TCP 等互联网协议 [1,9]，这尤其重要，因为数据包可能需要经过无线网络，如分组无线网络 [2] 和大西洋卫星网络 [3]，这些网络中数据包容易受到损坏。对于某些互联网协议（例如实时语音传输协议），系统可以容忍一定程度的传输错误，且可能通过前向纠错技术或者甚至完全不使用校验和来提高效率。但本文关注的是像 TCP 这样的协议，在这些协议中，可靠的数据传输是通过重传机制来实现的。</p>
<p>即便一个接收到的消息在校验和上看似正确，消息内部依然可能包含未被检测到的错误。这种错误发生的概率被限定为 2−C2^{-C}，其中 CC 是校验和的比特数。错误可能由硬件或软件故障、以及传输错误引起。硬件故障通常会以某些已知的方式表现出来，因此在设计校验和函数时，考虑这些常见的硬件故障类型是非常重要的。理想情况下，任何类型的常见硬件故障都不应该被漏检。</p>
<p>当前校验和函数能有效地检测到的一个故障示例是，当网络接口（或 I/O 总线、内存通道等）出现比特错误时，校验和将始终显示错误。然而，假设网络接口的一个控制信号失效，导致接口将零代替真实数据存储，这种“全零”消息可能会看起来具有有效的校验和。在 ARPANET 接口的“这是你的比特”线路 [4] 上的噪声也可能被漏检，因为额外输入的比特可能导致校验和与数据一样发生位移（即：扰动）。</p>
<p>尽管偶尔会有包含未检测错误的消息被传递到协议的更高层，但这些消息在更高层的协议中通常无法被理解。在 TCP 的情况下，大部分此类消息会被忽略，但有些消息可能会导致连接中断。损坏的数据可能会在 TCP 之上的协议层面被视为问题，而这些协议本身可能也有自己的校验和机制。</p>
<p>本文是设计新校验和函数的第一步，旨在改进 TCP 及其他互联网协议的校验和。我们识别了当前校验和函数的一些有用特性，并希望在任何新函数中尽可能保留这些特性。文章中还探讨了几种可行的校验和方案，其中只有“乘积码”（product code）方案看起来简单到足以进行考虑。</p>
<h3 id="2-当前的-TCP-校验和函数"><a href="#2-当前的-TCP-校验和函数" class="headerlink" title="2. 当前的 TCP 校验和函数"></a>2. 当前的 TCP 校验和函数</h3><p>当前的校验和函数主要面向16位机器，如PDP-11，但也可以轻松地在其他机器（例如PDP-10）上计算。数据包被视为一串16位字节，校验和函数是这些字节的“反码求和”（加法并进行环绕进位）。最终存储在 TCP 头部校验和字段中的值是该求和的反码。发送方在计算校验和之前，会将数据包的校验和字段置为零。如果接收方计算出的校验和为零，则认为数据包有效。这是因为校验和字段中的“负数”会正好抵消数据包其余部分的贡献。</p>
<p>忽略实际评估给定数据包校验和函数的复杂性，以上描述的校验和使用方法非常简单，但它假设了校验和操作符的一些特性（即反码加法，“+”）：</p>
<ul>
<li><strong>(P1)</strong> 加法是交换的。因此，16位字节“加”在一起的顺序不重要。</li>
<li><strong>(P2)</strong> 加法有至少一个恒等元（当前函数有两个：+0 和 -0）。这使得发送方可以在计算校验和值之前，将数据包的校验和字段置为零。</li>
<li><strong>(P3)</strong> 加法有逆元。因此，接收方可以计算校验和并期望得到零。</li>
<li><strong>(P4)</strong> 加法是结合的，允许校验和字段位于数据包的任何位置，并且可以顺序扫描16位字节。</li>
</ul>
<p>从数学角度看，二进制运算符“+”在16位数字集上具有以上特性，形成了一个阿贝尔群 [5]。当然，存在许多阿贝尔群，但并非所有的阿贝尔群都适合用作校验和操作符。（例如，PDP-11指令集中另一个满足这些特性的运算符是异或（XOR），但由于其他原因，XOR并不适用。）</p>
<p>尽管不够精确，但任何未来的校验和方案都必须保留以下性质：</p>
<ul>
<li><strong>(P5)</strong> 加法应在各种机器上快速计算，并且对存储的需求应当有限。</li>
</ul>
<p>当前的校验和函数在这方面做得很好。例如，在PDP-11上，内循环如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LOOP:   ADD (R1)+,R0    ; 将下一个16位字节加到R0</span><br><span class="line">        ADC R0          ; 进行环绕进位</span><br><span class="line">        SOB R2,LOOP     ; 循环遍历整个数据包</span><br></pre></td></tr></table></figure>
<p>（每处理一个16位字节需要4个内存周期）</p>
<p>在PDP-10上，利用P1到P4的特性进一步优化，每次循环处理两个16位字节：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LOOP: ILDB THIS,PTR   ; 获取两个16位字节</span><br><span class="line">      ADD SUM,THIS    ; 加到当前和</span><br><span class="line">      JUMPGE SUM,CHKSU2  ; 如果进位少于8次，跳转</span><br><span class="line">      LDB THIS,[POINT 20,SUM,19] ; 获取左16位和进位</span><br><span class="line">      ANDI SUM,177777 ; 仅保存低16位</span><br><span class="line">      ADD SUM,THIS    ; 加入进位</span><br><span class="line">CHKSU2: SOJG COUNT,LOOP ; 循环遍历整个数据包</span><br></pre></td></tr></table></figure>
<p>（每处理一个16位字节需要3.1个内存周期）</p>
<p>上面循环中的“额外”指令用于将二进制补码加法转换为反码加法，通过使进位环绕。使用反码加法比使用二进制补码加法更好，因为它对所有比特位置的错误都同样敏感。如果使用二进制补码加法，则可能会在最重要的比特位置丢失（或获得）偶数个1，而不会影响校验和的值。正是这个特性使得某种加法比简单的异或更合适，而后者允许任何比特通道中偶数个比特丢失（或获得）。PDP-10上使用的RIM10B纸带格式 [10] 采用了二进制补码加法，因为加载程序的空间非常有限。</p>
<p>当前校验和方案的另一个特性是：</p>
<ul>
<li><strong>(P6)</strong> 将校验和添加到数据包中不会改变信息字节。Peterson [6] 将此称为“系统化”编码。</li>
</ul>
<p>这个特性允许中间计算机（如网关机器）在不解码数据包的情况下处理数据包中的字段（例如互联网目标地址）。错误检测的循环冗余校验（CRC）则不是系统化的。然而，大多数CRC的应用侧重于错误检测而非纠错，因此可以直接发送未修改的消息，只需在数据包末尾附加CRC校验码。ARPANET IMP和远程主机接口 [4] 使用的24位CRC，以及ANSI标准用于800和6250位每英寸磁带的CRC [11]，都采用这种模式。</p>
<p>需要注意的是，较高层协议的操作通常不会（按设计）受到网关可能对无效数据包所做的任何处理的影响。网关可以验证传入数据包的校验和，但通常如果校验和是协议特定的特性，网关并不知道如何进行验证。</p>
<p>当前校验和方案的最后一个特性，其实是P1和P4的结果：</p>
<ul>
<li><strong>(P7)</strong> 校验和可以被增量修改。</li>
</ul>
<p>这个特性使得中间网关可以在数据包中添加信息（例如时间戳），并“添加”适当的修改到数据包的校验和字段中。需要注意的是，校验和依然是端到端的，因为它并没有被完全重新计算。</p>
<h3 id="3-产品码（Product-Codes）"><a href="#3-产品码（Product-Codes）" class="headerlink" title="3. 产品码（Product Codes）"></a>3. 产品码（Product Codes）</h3><p>某些“产品码”在校验和（checksum）处理中可能非常有用。以下是产品码在TCP协议中的简要描述。有关更一般的讨论，可以参考Avizienis [7]及其他一些较新的文献。</p>
<p>产品码的基本概念是，发送的消息（数据包）是通过转换原始源消息并添加一些“检查”位来形成的。接收方通过读取这些位并应用一个（可能不同的）转换，可以重构原始消息并判断其在传输过程中是否被损坏。</p>
<h4 id="产品码的工作原理："><a href="#产品码的工作原理：" class="headerlink" title="产品码的工作原理："></a>产品码的工作原理：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Mo        Ms          Mr</span><br><span class="line">-----    -----      ----</span><br><span class="line">| A |  code    | 7 |   decode  | A |</span><br><span class="line">| B |    ==&gt;   | 1 |     ==&gt;   | B |</span><br><span class="line">| C |          | 4 |           | C |</span><br><span class="line">-----          |...|           ----</span><br><span class="line">               | 2 | check     plus "valid" flag</span><br><span class="line">               ----- info</span><br></pre></td></tr></table></figure>
<p>使用产品码时，发送的消息 <code>Ms</code> 是通过将原始消息 <code>Mo</code> 与某个已知常数 <code>K</code> 相乘得到的。即： Ms=K×MoMs = K \times Mo 接收方解码时，将接收到的消息 <code>Ms</code> 除以 <code>K</code>，如果消息没有损坏，商 <code>Mr</code> 就会等于 <code>Mo</code>，余数为零。</p>
<h3 id="问题和注意事项："><a href="#问题和注意事项：" class="headerlink" title="问题和注意事项："></a>问题和注意事项：</h3><ol>
<li><p><strong>选择合适的检查因子 <code>K</code>：</strong> 选择 <code>K</code> 时，必须确保它与用于表示消息的基数互质。例如，对于二进制消息，如果 <code>K</code> 被错误地选择为8，那么 <code>Ms</code> 看起来和 <code>Mo</code> 一模一样，只是附加了三个零。接收方只能通过检测到的错误位置来判断消息是否出现问题。</p>
</li>
<li><p><strong>对于TCP协议，基数 <code>R</code> 选择为 2162^{16}</strong>： 每个16位字节（PDP-11上的一个字）被视为一个大数字的数字位，整个消息就被当做这个大数字来处理。因此，消息 <code>Mo</code> 可以表示为：</p>
<p>Mo=∑i=0NBi×(Ri)Mo = \sum_{i=0}^{N} B_i \times (R^i)</p>
<p>其中 BiB_i 是第 <code>i</code> 个字节。将 <code>Mo</code> 与 <code>K</code> 相乘得到 <code>Ms</code>，如果数据包出现了单个字节的损坏，接收到的 <code>Ms'</code> 就会变成：</p>
<p>Ms′=Ms+C×(Rj)Ms’ = Ms + C \times (R^j)</p>
<p>对接收到的消息 <code>Ms'</code> 进行 <code>K</code> 除法时，会得到一个非零余数，表示消息 <code>Ms'</code> 被破坏。</p>
</li>
<li><p><strong>选择一个合适的 <code>K</code>：</strong> 为了检测到所有位突发错误，选择的 <code>K</code> 需要是 216−12^{16} - 1，这样所有小于等于15位的错误都会被检测出来。</p>
</li>
</ol>
<h3 id="实现："><a href="#实现：" class="headerlink" title="实现："></a>实现：</h3><ol>
<li><p><strong>乘法与除法的计算：</strong> 乘法和除法通常是比较复杂的运算，尤其是在存储和运算能力有限的小型机器上。然而，在这里的特定情况下，由于 <code>K</code> 选择为 216−12^{16} - 1，可以通过简单的数字和运算快速检查校验和。</p>
</li>
<li><p><strong>例子：</strong> 在十进制中，基数为10时，选择 <code>Q=6</code>，则：</p>
<p>6=0×9+6=6mod  96 = 0 \times 9 + 6 = 6 \mod 9</p>
<p>60=6×9+6=6mod  960 = 6 \times 9 + 6 = 6 \mod 9</p>
<p>600=66×9+6=6mod  9600 = 66 \times 9 + 6 = 6 \mod 9</p>
<p>同理，对于基数 R=216R = 2^{16}，校验和的计算也可以通过对各个字节求和来实现。</p>
</li>
<li><p><strong>编码过程：</strong> 发送方需要将多精度的消息 <code>Mo</code> 乘以 216−12^{16} - 1。这可以通过将 <code>Mo</code> 右移一个字长的位数然后减去 <code>Mo</code> 来实现。由于需要跨越字节的进位，因此采用的是补码运算。</p>
<p>在PDP-11上的伪代码可能如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LOOP:   MOV -2(R2), R0   ; 取 (2^16) * Mo 的下一个字节</span><br><span class="line">        SBC R0           ; 处理上一个减法的进位</span><br><span class="line">        SUB (R2)+, R0    ; 减去 Mo 的下一个字节</span><br><span class="line">        MOV R0, (R3)+    ; 存储到 Ms</span><br><span class="line">        SOB R1, LOOP     ; 遍历整个消息</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>接收方解码：</strong> 在接收方，解码过程是通过观察每个 <code>Ms</code> 中的字来推算原始消息 <code>Mo</code>。由于在每个字中都包含了相邻两个字的差异，且低位字包含的是负的低位字，因此接收方可以逐步重建出原始消息。</p>
</li>
</ol>
<h3 id="额外的优化："><a href="#额外的优化：" class="headerlink" title="额外的优化："></a>额外的优化：</h3><ol>
<li><strong>防止全零消息：</strong> 当一个消息完全是零时，除以 <code>K</code> 会得到零，导致其看起来像是一个有效的消息。为此，可以引入一个常量 <code>C</code>，例如 <code>C=1</code>，以保证即使消息全为零也能正确处理。</li>
<li><strong>性能评估：</strong> 相比当前的TCP校验和算法，产品码算法的计算时间大约是当前算法的两倍（即 <code>P5</code> 被满足）。尽管如此，由于它具有较高的错误检测能力，仍然是一个可行的选择。</li>
<li><strong>网关兼容性：</strong> 产品码校验和虽然不是系统化的（即不是每次都能得到有效的校验和），但它仍然能够快速验证消息的完整性，特别是当互联网目的地址位于数据包的低位部分时，网关可以在不解码整个消息的情况下进行校验。</li>
</ol>
<p>总结来说，产品码校验和提供了一个强大的错误检测机制，能够通过简单的数字操作检测到消息中的错误，并且在TCP协议中能够快速实现。</p>
<h3 id="4-更复杂的编码（More-Complicated-Codes）"><a href="#4-更复杂的编码（More-Complicated-Codes）" class="headerlink" title="4. 更复杂的编码（More Complicated Codes）"></a>4. 更复杂的编码（More Complicated Codes）</h3><p>错误检测和纠正编码理论有着丰富的研究，Peterson [6] 是一个很好的参考。大多数“CRC”（循环冗余校验）方案是通过使用带反馈网络的移位寄存器来实现的，这个反馈网络由异或门（exclusive-ORs）构成。如果用程序来模拟这种逻辑电路，它的速度会太慢，无法满足实际需求，除非发现某些编程技巧。</p>
<p>一种被提出的技巧是由Kirstein [8] 提出的。基本上，当前移位寄存器状态的几位（四位或八位）与输入流（来自Mo的消息）中的位结合，结果用作查找表的索引，查找表给出新的移位寄存器状态，以及如果编码不是系统化的，输出流（Ms）中的位。对一个使用四位字节的特别“优良”CRC函数进行的试验编码显示，这种技巧使得编码速度大约是当前校验和函数的四倍。这在PDP-10和PDP-11机器上都是如此。</p>
<p>对于上述所列的期望特性，CRC方案仅满足以下两个特性：</p>
<ul>
<li><strong>P3</strong>（它具有反向运算）。</li>
<li><strong>P6</strong>（它是系统化的）。</li>
</ul>
<p>校验和字段在数据包中的位置非常关键，并且CRC不能被增量修改。</p>
<p>虽然编码理论的主要部分是针对二进制码的，但如果字母表包含 <code>q</code> 个符号，其中 <code>q</code> 是质数的幂，那么大部分理论同样适用。例如，选择 <code>q = 2^{16}</code>，就可以使得很多编码理论适用于按字处理。</p>
<h3 id="5-外部处理（Outboard-Processing）"><a href="#5-外部处理（Outboard-Processing）" class="headerlink" title="5. 外部处理（Outboard Processing）"></a>5. 外部处理（Outboard Processing）</h3><p>当像计算复杂的校验和这样的函数需要大量处理时，一种解决方案是将处理任务交给外部处理器。这样，“编码消息”和“解码消息”就成为了单一指令，能够避免占用主机处理器的资源。数字设备公司（DEC）生产的VAX/780计算机配备了专门的硬件来生成和检查CRC [13]。然而，一般来说，这种方案并不是一个很好的解决方法，因为每种不同的主机都需要为其构建一个专门的处理器，来处理TCP消息。</p>
<p>可以设想，某些大型主机的网关功能完全可以由一个“互联网前端机器”来完成。该机器将负责转发从网络接收的分组，或者从连接的主机的互联网协议模块接收的数据包，并将这些数据包重组为互联网段，传递给主机。该机器的另一项功能是检查校验和，以确保传递给主机的段在离开前端时已经是有效的。由于计算机周期被认为是廉价且可用的，这种方法是合理的。</p>
<h3 id="问题与挑战："><a href="#问题与挑战：" class="headerlink" title="问题与挑战："></a>问题与挑战：</h3><p>将校验和验证工作放在前端进行，会破坏校验和的端到端特性。如果要实现这个功能，必须构建一个额外的协议来覆盖主机与前端机器之间的链接。具体做法是，前端机器在验证完从网络接收的数据包后，会将该数据包传递给主机，并告诉主机：“这是一个来自互联网的段，编号为 #123”。主机会保存这个段，并将其副本返回给前端机器，告诉前端：“这是你给我的 #123。它没问题吗？”然后，前端机器会与第一次传送的内容进行逐字对比，并告诉主机：“这是 #123 再次给你”，或者“你确实已经正确接收了 #123，放行它交给相应的模块进行处理。”</p>
<p>跨越主机与前端链接的消息头通常会使用一个较强的校验和，以确保其中的功能和消息参考编号等信息是可靠的。这些头部通常非常短，可能只有16位，因此校验和可以做得非常强大。消息的主体部分则通常不进行校验。</p>
<h3 id="优势与问题："><a href="#优势与问题：" class="headerlink" title="优势与问题："></a>优势与问题：</h3><p>这种方案减轻了主机的计算负担，因为验证消息的唯一要求是将它返回给前端机器。在PDP-10的例子中，这仅需每16位字节的互联网消息0.5个内存周期，并且仅需几个处理器周期来设置所需的传输操作。</p>
<p>然而，这种方法的一个问题是，它破坏了TCP校验和的端到端特性，而这正是该校验和最强大的特性之一。</p>
<h3 id="6-结论（Conclusions）"><a href="#6-结论（Conclusions）" class="headerlink" title="6. 结论（Conclusions）"></a>6. 结论（Conclusions）</h3><p>校验和函数是有序的，最简单的排序方式如下：</p>
<ol>
<li><strong>没有校验和</strong>：这种方法不提供任何错误检测或纠正。</li>
<li><strong>发送一个常数</strong>：接收方检查这个常数，但这种方法非常弱。</li>
<li><strong>数据的异或（XOR）</strong>：将数据进行异或运算并发送。XOR运算所需的计算时间最少，但它并不是一个好的校验和。</li>
<li><strong>数据的二进制反码和</strong>：这种方法比异或稍微好一些，且计算时间不超过其他方法。</li>
<li><strong>一的补码和</strong>：TCP协议当前使用的就是这种方法。它在计算上稍微更昂贵一些，但提供了更好的错误检测能力。</li>
<li><strong>乘积编码（Product Code）</strong>：乘积编码与一的补码和密切相关，使用时需要更多的计算时间，提供了一定的抗硬件故障的能力，但它也有一些不太理想的特性。</li>
<li><strong>真正的CRC多项式编码</strong>：这种方法仅用于检测，程序实现起来非常昂贵。</li>
<li><strong>完整的CRC错误检测和纠正方案</strong>：这是一种最全面的错误检测与纠正方案。</li>
</ol>
<p>对于TCP和互联网应用来说，<strong>乘积编码方案</strong>是可行的。它的主要问题在于，消息必须至少部分解码，以便通过中间网关进行转发。若不选择乘积编码作为改进的校验和方案，也可以对现有方案做一些轻微的修改。例如，<strong>“加法与旋转”（add and rotate）</strong>函数，曾由麻省理工学院人工智能实验室的PDP-6/10小组在纸带处理中使用，可能会有用，前提是能够证明它比现有方案更好，并且能够在多种机器上高效计算。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag"># 计算机网络</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2024/11/17/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93-%E9%80%89%E8%AF%BE%E7%B3%BB%E7%BB%9F%E6%9F%A5%E8%AF%A2/" rel="prev" title="MySQL数据库-选课系统查询">
      <i class="fa fa-chevron-left"></i> MySQL数据库-选课系统查询
    </a></div>
      <div class="post-nav-item">
    <a href="/2024/12/01/LG-P1007-%E7%8B%AC%E6%9C%A8%E6%A1%A5/" rel="next" title="LG_P1007.独木桥">
      LG_P1007.独木桥 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E6%96%87%E7%BF%BB%E8%AF%91"><span class="nav-number">1.</span> <span class="nav-text">原文翻译</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%91%98%E8%A6%81"><span class="nav-number">1.1.</span> <span class="nav-text">摘要</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.2.</span> <span class="nav-text">1. 介绍</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E8%AE%A1%E7%AE%97%E6%A0%A1%E9%AA%8C%E5%92%8C"><span class="nav-number">2.</span> <span class="nav-text">2. 计算校验和</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#A-%E4%BA%A4%E6%8D%A2%E5%BE%8B%E4%B8%8E%E7%BB%93%E5%90%88%E5%BE%8B"><span class="nav-number">2.1.</span> <span class="nav-text">(A) 交换律与结合律</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#B-%E5%AD%97%E8%8A%82%E9%A1%BA%E5%BA%8F%E7%8B%AC%E7%AB%8B%E6%80%A7"><span class="nav-number">2.2.</span> <span class="nav-text">(B) 字节顺序独立性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#C-%E5%B9%B6%E8%A1%8C%E6%B1%82%E5%92%8C"><span class="nav-number">2.3.</span> <span class="nav-text">(C) 并行求和</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E8%BF%9B%E4%B8%80%E6%AD%A5%E4%BC%98%E5%8C%96%E6%A0%A1%E9%AA%8C%E5%92%8C%E8%AE%A1%E7%AE%97"><span class="nav-number">3.</span> <span class="nav-text">3.进一步优化校验和计算</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%BB%B6%E8%BF%9F%E8%BF%9B%E4%BD%8D%EF%BC%88Deferred-Carries%EF%BC%89"><span class="nav-number">3.1.</span> <span class="nav-text">(1) 延迟进位（Deferred Carries）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%B1%95%E5%BC%80%E5%BE%AA%E7%8E%AF%EF%BC%88Unwinding-Loops%EF%BC%89"><span class="nav-number">3.2.</span> <span class="nav-text">(2) 展开循环（Unwinding Loops）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%A4%8D%E5%88%B6%E7%BB%93%E5%90%88%EF%BC%88Combine-with-Data-Copying%EF%BC%89"><span class="nav-number">3.3.</span> <span class="nav-text">(3) 与数据复制结合（Combine with Data Copying）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E5%A2%9E%E9%87%8F%E6%9B%B4%E6%96%B0%EF%BC%88Incremental-Update%EF%BC%89"><span class="nav-number">3.4.</span> <span class="nav-text">(4) 增量更新（Incremental Update）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97%E7%A4%BA%E4%BE%8B"><span class="nav-number">4.</span> <span class="nav-text">4. 数值计算示例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E8%8A%82%E9%80%90%E6%AD%A5%E8%AE%A1%E7%AE%97%E3%80%81%E6%AD%A3%E5%B8%B8%E9%A1%BA%E5%BA%8F%E5%92%8C%E4%BA%A4%E6%8D%A2%E9%A1%BA%E5%BA%8F"><span class="nav-number">4.1.</span> <span class="nav-text">字节逐步计算、正常顺序和交换顺序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#32%E4%BD%8D%E5%AD%97%E9%80%90%E6%AD%A5%E8%AE%A1%E7%AE%97%EF%BC%883%E7%A7%8D%E4%B8%8D%E5%90%8C%E7%9A%84%E9%A1%BA%E5%BA%8F%EF%BC%89"><span class="nav-number">4.2.</span> <span class="nav-text">32位字逐步计算（3种不同的顺序）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E7%BB%84%E8%AE%A1%E7%AE%97%E7%A4%BA%E4%BE%8B"><span class="nav-number">4.3.</span> <span class="nav-text">分组计算示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E5%AE%9E%E7%8E%B0%E7%A4%BA%E4%BE%8B"><span class="nav-number">5.</span> <span class="nav-text">4. 实现示例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-%E4%BD%BF%E7%94%A8-%E2%80%9CC%E2%80%9D-%E5%AE%9E%E7%8E%B0%E7%9A%84%E4%BA%92%E8%81%94%E7%BD%91%E6%A0%A1%E9%AA%8C%E5%92%8C%E7%AE%97%E6%B3%95"><span class="nav-number">5.1.</span> <span class="nav-text">4.1 使用 “C” 实现的互联网校验和算法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BF%BB%E8%AF%91%E5%8F%8A%E8%A7%A3%E9%87%8A"><span class="nav-number">6.</span> <span class="nav-text">翻译及解释</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E8%AF%B4%E6%98%8E"><span class="nav-number">7.</span> <span class="nav-text">示例说明</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-Motorola-68020"><span class="nav-number">7.1.</span> <span class="nav-text">4.2 Motorola 68020</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BF%BB%E8%AF%91%E5%8F%8A%E8%A7%A3%E9%87%8A-1"><span class="nav-number">8.</span> <span class="nav-text">翻译及解释</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%A7%E8%83%BD%E7%89%B9%E7%82%B9"><span class="nav-number">9.</span> <span class="nav-text">性能特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-Cray"><span class="nav-number">10.</span> <span class="nav-text">4.3 Cray</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BF%BB%E8%AF%91%E5%8F%8A%E8%A7%A3%E9%87%8A-2"><span class="nav-number">11.</span> <span class="nav-text">翻译及解释</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%A7%E8%83%BD%E7%89%B9%E7%82%B9-1"><span class="nav-number">12.</span> <span class="nav-text">性能特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-IBM-370"><span class="nav-number">13.</span> <span class="nav-text">4.4 IBM 370</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BF%BB%E8%AF%91%E5%8F%8A%E8%A7%A3%E9%87%8A-3"><span class="nav-number">14.</span> <span class="nav-text">翻译及解释</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%A7%E8%83%BD%E8%AF%B4%E6%98%8E"><span class="nav-number">15.</span> <span class="nav-text">性能说明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%BC%95%E8%A8%80"><span class="nav-number">16.</span> <span class="nav-text">1. 引言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%BD%93%E5%89%8D%E7%9A%84-TCP-%E6%A0%A1%E9%AA%8C%E5%92%8C%E5%87%BD%E6%95%B0"><span class="nav-number">17.</span> <span class="nav-text">2. 当前的 TCP 校验和函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E4%BA%A7%E5%93%81%E7%A0%81%EF%BC%88Product-Codes%EF%BC%89"><span class="nav-number">18.</span> <span class="nav-text">3. 产品码（Product Codes）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%A7%E5%93%81%E7%A0%81%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%9A"><span class="nav-number">18.1.</span> <span class="nav-text">产品码的工作原理：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E5%92%8C%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%EF%BC%9A"><span class="nav-number">19.</span> <span class="nav-text">问题和注意事项：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%EF%BC%9A"><span class="nav-number">20.</span> <span class="nav-text">实现：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%9D%E5%A4%96%E7%9A%84%E4%BC%98%E5%8C%96%EF%BC%9A"><span class="nav-number">21.</span> <span class="nav-text">额外的优化：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E6%9B%B4%E5%A4%8D%E6%9D%82%E7%9A%84%E7%BC%96%E7%A0%81%EF%BC%88More-Complicated-Codes%EF%BC%89"><span class="nav-number">22.</span> <span class="nav-text">4. 更复杂的编码（More Complicated Codes）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E5%A4%96%E9%83%A8%E5%A4%84%E7%90%86%EF%BC%88Outboard-Processing%EF%BC%89"><span class="nav-number">23.</span> <span class="nav-text">5. 外部处理（Outboard Processing）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E4%B8%8E%E6%8C%91%E6%88%98%EF%BC%9A"><span class="nav-number">24.</span> <span class="nav-text">问题与挑战：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E5%8A%BF%E4%B8%8E%E9%97%AE%E9%A2%98%EF%BC%9A"><span class="nav-number">25.</span> <span class="nav-text">优势与问题：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E7%BB%93%E8%AE%BA%EF%BC%88Conclusions%EF%BC%89"><span class="nav-number">26.</span> <span class="nav-text">6. 结论（Conclusions）</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">P4yl04d</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">45</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">24</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">P4yl04d</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = 'true';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
