---
title: LC005
date: 2023-11-28 13:06:02
tags:
- 哈希表
- 
categories:
- [算法,数据结构,哈希表]
---

`Leetcode`刷题记录，主要涉及哈希表

<!--more-->

# 两数之和

## 题目描述

给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 **和为目标值** *`target`* 的那 **两个** 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

你可以按任意顺序返回答案。

 

**示例 1：**

```
输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
```

**示例 2：**

```
输入：nums = [3,2,4], target = 6
输出：[1,2]
```

**示例 3：**

```
输入：nums = [3,3], target = 6
输出：[0,1]
```

 

**提示：**

- `2 <= nums.length <= 104`
- `-109 <= nums[i] <= 109`
- `-109 <= target <= 109`
- **只会存在一个有效答案**

 

**进阶：**你可以想出一个时间复杂度小于 `O(n2)` 的算法吗？

## 题目解法

### 常规解法

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        int length = nums.length;
        for(int i = 0;i < length - 1;i++){
            for(int j = i + 1;j < length;j++){
                if(nums[i] + nums[j] == target){
                    return new int[]{i,j};
                }
            }
        }
        return new int[0];
    }
}
```

1.这里注意**11**行有可能找不到对应的数组下标，此时`return new int[0]`

> `new int[0]` 是在 Java 中创建一个新的整数数组，但这个数组的长度为0。这意味着这个数组不包含任何元素。虽然这个数组看起来可能没什么用，但在某些情况下，它可以作为一个有效的非空对象返回，以避免返回 null 并可能导致 `NullPointerException`。这是一种编程技巧，用于处理可能没有数据返回的情况。总的来说，`new int[0]` 创建了一个空的整数数组。

2.还有**7**行返回两个数组下标的方法:`return new int []{i,j}`

3.`length`是属性，不是方法。直接`int length = nums.length`即可，无需加括号。

### 哈希表

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> hashtable = new HashMap<Integer, Integer>();
        for (int i = 0; i < nums.length; ++i) {
            if (hashtable.containsKey(target - nums[i])) {
                return new int[]{hashtable.get(target - nums[i]), i};
            }
            hashtable.put(nums[i], i);
        }
        return new int[0];
    }
}
```

> 在哈希表中，`containsKey`方法的平均时间复杂度是O(1)，这意味着无论哈希表的大小如何，查找一个键的时间都是常数。这是因为哈希表使用哈希函数将键映射到一个特定的桶，然后在该桶中查找键，而桶的数量通常是固定的。
>
> 然而，这只是平均情况。在最坏的情况下，如果所有的键都哈希到同一个桶，那么查找一个键的时间复杂度将是O(n)，其中n是哈希表中键的数量。但是，如果哈希函数设计得好，并且键的分布是均匀的，那么这种情况是非常罕见的。
>
> 所以，当我们说`containsKey`方法的时间复杂度是O(1)，我们是指在平均情况下。而在你的代码中，你遍历了数组一次，每次调用`containsKey`方法一次，所以总的时间复杂度是O(n)。

比如输入数组是输入：`nums = [2,7,11,15], target = 9`

第一步，利用`Map<Integer,Integer> hashtable = new HashMap<Integer,Integer>()`创建了一个空的`HashMap`。

第二步，执行循环，当`i = 0`时，哈希表中显然没有`Key`值为`9 - 2 = 7`的桶，所以，执行`hashtable.put(nums[i],i)`，把`2`当作`Key`,把·`0`当作`Value`放入哈希表。当执行到`i = 1`时，哈希表中有`Key`值为`9 - 7 = 2`的桶（上一步放进去的）。因此直接返回该桶的`Value`为`0`,以及这个`i`为`1`。所以返回数组`return new int[]{ 0 , 1}`，符合预取。

