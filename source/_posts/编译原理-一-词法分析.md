---
title: 编译原理(一).词法分析
date: 2024-03-29 13:37:01
tags:
categories:
---

本文介绍了正则表达式

<!--more-->

github.com/riscv/riscv-gcc

### 正则表达式

> 正则表达式是语法

>  正则语言是语义
>
> 正则表达式定义了一个正则语言，为集合
>
> 形如L(正则表达式)

![image-20240329134743310](../../../../Pictures/Blog/编译原理-一-词法分析/image-20240329134743310.png)

eg.C语言标识符的正则表达式

```c
^[a-zA-Z_](a-zA-Z\d)*$
```

> `^`和`$`限定在一行中匹配
>
> `[a-zA-Z_]`表示以下划线或大小写字母开头
>
> `(a-zA-Z\d)*`表示开头跟着0个或多个字母或数字

eg.C语言单行注释

```c
\/\/.
```

> `\/`匹配`/`的字面值
>
> `.`匹配除了换行外的所有
>
> 无需加`^`匹配开头

```c
int a = 0; //这里的注释并非从开头写的也有效
```

eg.C语言多行注释

```c
\/\*[\s\S]*?\*/\
```

> `\/\*\*\/`是多行注释的字面形式
>
> `[\s\S]*?`的作用是匹配任意字符
>
> `\s` 表示空白字符（包括空格、制表符、换行符等）
>
> `\S` 则表示非空白字符。
>
> `*`表示匹配一次或多次
>
> `?`用来尽可能减少匹配次数，遇到第一个`*/`停止

eg.三的倍数

```c
(0|(1(01*0)*1))*
```

### Flex代码编写

```c
%{
    #include "stdio.h"
%}


```

## 手撸代码

### 预处理

**实验要求：**

1.合并空白符：把原始程序中相邻的空格、制表符、回车等空白符合并成一个空格，便于后续处理

2.消除注释：消除原始程序中的注释内容；PL/0语法中没有规定注释的格式，参照Pascal语言规定如下两种注释格式：

-  单行注释：“//”引导内容，与C++语言中单行注释一致。

- 多行注释：“(\*”和“\*)”之间内容，具体参见后面示例程序。

**合并实现思路**

写一个`mergeWhitespace`函数，传入的参数为打开的文件描述符,仅仅对文件描述符打开的文件进行读取，读到缓冲区，再从缓冲区写到新文件，返回新文件的文件描述符，新文件命名为`filename.i`。有点类似C#网络应用编程的思路

> 为了和词法分析程序的耦合型，换成了FILE*作为参数的fread函数和fopen函数

代码如下：

```
if (currentChar == ' ' || currentChar == '\t' || currentChar == '\n' || currentChar == '\r') {
                // 如果当前字符是空白符，检查下一个字符是否也是空白符
                while (i + 1 < bytesRead && (buffer[i + 1] == ' ' || buffer[i + 1] == '\t' || buffer[i + 1] == '\n' || buffer[i + 1] == '\r')) {
                    i++;  // 跳过相邻的空白符
                }
                mergedBuffer[mergedIndex++] = ' ';  // 合并为一个空格
            } else {
                mergedBuffer[mergedIndex++] = currentChar;  // 非空白符，直接复制
```





### 代码修改

1.保留字提示改成关键字

2.最后为什么输出`ERRO`

3.以命令行参数的形式传入参数

4.各种输出显示仍然有点问题

